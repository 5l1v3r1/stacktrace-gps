{"version":3,"sources":["stackframe.js","stacktrace-gps.js"],"names":["root","factory","define","amd","exports","module","StackFrame","this","_isNumber","n","isNaN","parseFloat","isFinite","_capitalize","str","charAt","toUpperCase","substring","_getter","p","obj","Object","i","props","length","hasOwnProperty","undefined","booleanProps","numericProps","stringProps","arrayProps","concat","prototype","getArgs","args","setArgs","v","toString","call","TypeError","getEvalOrigin","evalOrigin","setEvalOrigin","fileName","getFileName","lineNumber","getLineNumber","columnNumber","getColumnNumber","functionName","getFunctionName","getIsEval","fromString","argsStartIndex","indexOf","argsEndIndex","lastIndexOf","split","locationString","parts","exec","Boolean","j","Number","k","String","require","StackTraceGPS","SourceMap","sourceMap","_xdr","url","Promise","resolve","reject","req","XMLHttpRequest","open","onerror","onreadystatechange","readyState","status","substr","responseText","Error","send","_atob","b64str","window","atob","_parseJson","string","JSON","parse","_findFunctionName","source","syntaxes","lines","code","maxLines","Math","min","line","commentPos","len","index","m","_ensureSupportedEnvironment","defineProperty","create","_ensureStackFrameIsLegit","stackframe","_findSourceMappingURL","lastSourceMappingUrl","matchSourceMappingUrl","sourceMappingUrlRegExp","_extractLocationInfoFromSourceMapSource","sourceMapConsumer","sourceCache","loc","originalPositionFor","column","mappedSource","sourceContentFor","name","opts","sourceMapConsumerCache","ajax","_get","location","isDataUrl","offline","supportedEncodingRegexp","match","sourceMapStart","encodedSource","xhrPromise","method","then","bind","_getSourceMapConsumer","sourceMappingURL","defaultSourceRoot","sourceMapConsumerPromise","sourceMapSource","replace","sourceRoot","SourceMapConsumer","pinpoint","getMappedLocation","mappedStackFrame","resolveMappedStackFrame","findFunctionName","guessedFunctionName","test"],"mappings":"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","file":"stacktrace-gps.min.js","sourcesContent":["(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stackframe', [], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.StackFrame = factory();\n    }\n}(this, function() {\n    'use strict';\n    function _isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    function _capitalize(str) {\n        return str.charAt(0).toUpperCase() + str.substring(1);\n    }\n\n    function _getter(p) {\n        return function() {\n            return this[p];\n        };\n    }\n\n    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n    var numericProps = ['columnNumber', 'lineNumber'];\n    var stringProps = ['fileName', 'functionName', 'source'];\n    var arrayProps = ['args'];\n\n    var props = booleanProps.concat(numericProps, stringProps, arrayProps);\n\n    function StackFrame(obj) {\n        if (obj instanceof Object) {\n            for (var i = 0; i < props.length; i++) {\n                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {\n                    this['set' + _capitalize(props[i])](obj[props[i]]);\n                }\n            }\n        }\n    }\n\n    StackFrame.prototype = {\n        getArgs: function() {\n            return this.args;\n        },\n        setArgs: function(v) {\n            if (Object.prototype.toString.call(v) !== '[object Array]') {\n                throw new TypeError('Args must be an Array');\n            }\n            this.args = v;\n        },\n\n        getEvalOrigin: function() {\n            return this.evalOrigin;\n        },\n        setEvalOrigin: function(v) {\n            if (v instanceof StackFrame) {\n                this.evalOrigin = v;\n            } else if (v instanceof Object) {\n                this.evalOrigin = new StackFrame(v);\n            } else {\n                throw new TypeError('Eval Origin must be an Object or StackFrame');\n            }\n        },\n\n        toString: function() {\n            var fileName = this.getFileName() || '';\n            var lineNumber = this.getLineNumber() || '';\n            var columnNumber = this.getColumnNumber() || '';\n            var functionName = this.getFunctionName() || '';\n            if (this.getIsEval()) {\n                if (fileName) {\n                    return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n                }\n                return '[eval]:' + lineNumber + ':' + columnNumber;\n            }\n            if (functionName) {\n                return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n            }\n            return fileName + ':' + lineNumber + ':' + columnNumber;\n        }\n    };\n\n    StackFrame.fromString = function StackFrame$$fromString(str) {\n        var argsStartIndex = str.indexOf('(');\n        var argsEndIndex = str.lastIndexOf(')');\n\n        var functionName = str.substring(0, argsStartIndex);\n        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');\n        var locationString = str.substring(argsEndIndex + 1);\n\n        if (locationString.indexOf('@') === 0) {\n            var parts = /@(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(locationString, '');\n            var fileName = parts[1];\n            var lineNumber = parts[2];\n            var columnNumber = parts[3];\n        }\n\n        return new StackFrame({\n            functionName: functionName,\n            args: args || undefined,\n            fileName: fileName,\n            lineNumber: lineNumber || undefined,\n            columnNumber: columnNumber || undefined\n        });\n    };\n\n    for (var i = 0; i < booleanProps.length; i++) {\n        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {\n            return function(v) {\n                this[p] = Boolean(v);\n            };\n        })(booleanProps[i]);\n    }\n\n    for (var j = 0; j < numericProps.length; j++) {\n        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {\n            return function(v) {\n                if (!_isNumber(v)) {\n                    throw new TypeError(p + ' must be a Number');\n                }\n                this[p] = Number(v);\n            };\n        })(numericProps[j]);\n    }\n\n    for (var k = 0; k < stringProps.length; k++) {\n        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {\n            return function(v) {\n                this[p] = String(v);\n            };\n        })(stringProps[k]);\n    }\n\n    return StackFrame;\n}));\n","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stacktrace-gps', ['source-map', 'stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('source-map/lib/source-map-consumer'), require('stackframe'));\n    } else {\n        root.StackTraceGPS = factory(root.SourceMap || root.sourceMap, root.StackFrame);\n    }\n}(this, function(SourceMap, StackFrame) {\n    'use strict';\n\n    /**\n     * Make a X-Domain request to url and callback.\n     *\n     * @param {String} url\n     * @returns {Promise} with response text if fulfilled\n     */\n    function _xdr(url) {\n        return new Promise(function(resolve, reject) {\n            var req = new XMLHttpRequest();\n            req.open('get', url);\n            req.onerror = reject;\n            req.onreadystatechange = function onreadystatechange() {\n                if (req.readyState === 4) {\n                    if ((req.status >= 200 && req.status < 300) ||\n                        (url.substr(0, 7) === 'file://' && req.responseText)) {\n                        resolve(req.responseText);\n                    } else {\n                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));\n                    }\n                }\n            };\n            req.send();\n        });\n\n    }\n\n    /**\n     * Convert a Base64-encoded string into its original representation.\n     * Used for inline sourcemaps.\n     *\n     * @param {String} b64str Base-64 encoded string\n     * @returns {String} original representation of the base64-encoded string.\n     */\n    function _atob(b64str) {\n        if (typeof window !== 'undefined' && window.atob) {\n            return window.atob(b64str);\n        } else {\n            throw new Error('You must supply a polyfill for window.atob in this environment');\n        }\n    }\n\n    function _parseJson(string) {\n        if (typeof JSON !== 'undefined' && JSON.parse) {\n            return JSON.parse(string);\n        } else {\n            throw new Error('You must supply a polyfill for JSON.parse in this environment');\n        }\n    }\n\n    function _findFunctionName(source, lineNumber/*, columnNumber*/) {\n        var syntaxes = [\n            // {name} = function ({args}) TODO args capture\n            /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/,\n            // function {name}({args}) m[1]=name m[2]=args\n            /function\\s+([^('\"`]*?)\\s*\\(([^)]*)\\)/,\n            // {name} = eval()\n            /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/,\n            // fn_name() {\n            /\\b(?!(?:if|for|switch|while|with|catch)\\b)(?:(?:static)\\s+)?(\\S+)\\s*\\(.*?\\)\\s*\\{/,\n            // {name} = () => {\n            /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*\\(.*?\\)\\s*=>/\n        ];\n        var lines = source.split('\\n');\n\n        // Walk backwards in the source lines until we find the line which matches one of the patterns above\n        var code = '';\n        var maxLines = Math.min(lineNumber, 20);\n        for (var i = 0; i < maxLines; ++i) {\n            // lineNo is 1-based, source[] is 0-based\n            var line = lines[lineNumber - i - 1];\n            var commentPos = line.indexOf('//');\n            if (commentPos >= 0) {\n                line = line.substr(0, commentPos);\n            }\n\n            if (line) {\n                code = line + code;\n                var len = syntaxes.length;\n                for (var index = 0; index < len; index++) {\n                    var m = syntaxes[index].exec(code);\n                    if (m && m[1]) {\n                        return m[1];\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n\n    function _ensureSupportedEnvironment() {\n        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {\n            throw new Error('Unable to consume source maps in older browsers');\n        }\n    }\n\n    function _ensureStackFrameIsLegit(stackframe) {\n        if (typeof stackframe !== 'object') {\n            throw new TypeError('Given StackFrame is not an object');\n        } else if (typeof stackframe.fileName !== 'string') {\n            throw new TypeError('Given file name is not a String');\n        } else if (typeof stackframe.lineNumber !== 'number' ||\n            stackframe.lineNumber % 1 !== 0 ||\n            stackframe.lineNumber < 1) {\n            throw new TypeError('Given line number must be a positive integer');\n        } else if (typeof stackframe.columnNumber !== 'number' ||\n            stackframe.columnNumber % 1 !== 0 ||\n            stackframe.columnNumber < 0) {\n            throw new TypeError('Given column number must be a non-negative integer');\n        }\n        return true;\n    }\n\n    function _findSourceMappingURL(source) {\n        var sourceMappingUrlRegExp = /\\/\\/[#@] ?sourceMappingURL=([^\\s'\"]+)\\s*$/mg;\n        var lastSourceMappingUrl;\n        var matchSourceMappingUrl;\n        while (matchSourceMappingUrl = sourceMappingUrlRegExp.exec(source)) { // jshint ignore:line\n            lastSourceMappingUrl = matchSourceMappingUrl[1];\n        }\n        if (lastSourceMappingUrl) {\n            return lastSourceMappingUrl;\n        } else {\n            throw new Error('sourceMappingURL not found');\n        }\n    }\n\n    function _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache) {\n        return new Promise(function(resolve, reject) {\n            var loc = sourceMapConsumer.originalPositionFor({\n                line: stackframe.lineNumber,\n                column: stackframe.columnNumber\n            });\n\n            if (loc.source) {\n                // cache mapped sources\n                var mappedSource = sourceMapConsumer.sourceContentFor(loc.source);\n                if (mappedSource) {\n                    sourceCache[loc.source] = mappedSource;\n                }\n\n                resolve(\n                    // given stackframe and source location, update stackframe\n                    new StackFrame({\n                        functionName: loc.name || stackframe.functionName,\n                        args: stackframe.args,\n                        fileName: loc.source,\n                        lineNumber: loc.line,\n                        columnNumber: loc.column\n                    }));\n            } else {\n                reject(new Error('Could not get original source for given stackframe and source map'));\n            }\n        });\n    }\n\n    /**\n     * @constructor\n     * @param {Object} opts\n     *      opts.sourceCache = {url: \"Source String\"} => preload source cache\n     *      opts.sourceMapConsumerCache = {/path/file.js.map: SourceMapConsumer}\n     *      opts.offline = True to prevent network requests.\n     *              Best effort without sources or source maps.\n     *      opts.ajax = Promise returning function to make X-Domain requests\n     */\n    return function StackTraceGPS(opts) {\n        if (!(this instanceof StackTraceGPS)) {\n            return new StackTraceGPS(opts);\n        }\n        opts = opts || {};\n\n        this.sourceCache = opts.sourceCache || {};\n        this.sourceMapConsumerCache = opts.sourceMapConsumerCache || {};\n\n        this.ajax = opts.ajax || _xdr;\n\n        this._atob = opts.atob || _atob;\n\n        this._get = function _get(location) {\n            return new Promise(function(resolve, reject) {\n                var isDataUrl = location.substr(0, 5) === 'data:';\n                if (this.sourceCache[location]) {\n                    resolve(this.sourceCache[location]);\n                } else if (opts.offline && !isDataUrl) {\n                    reject(new Error('Cannot make network requests in offline mode'));\n                } else {\n                    if (isDataUrl) {\n                        // data URLs can have parameters.\n                        // see http://tools.ietf.org/html/rfc2397\n                        var supportedEncodingRegexp =\n                            /^data:application\\/json;([\\w=:\"-]+;)*base64,/;\n                        var match = location.match(supportedEncodingRegexp);\n                        if (match) {\n                            var sourceMapStart = match[0].length;\n                            var encodedSource = location.substr(sourceMapStart);\n                            var source = this._atob(encodedSource);\n                            this.sourceCache[location] = source;\n                            resolve(source);\n                        } else {\n                            reject(new Error('The encoding of the inline sourcemap is not supported'));\n                        }\n                    } else {\n                        var xhrPromise = this.ajax(location, {method: 'get'});\n                        // Cache the Promise to prevent duplicate in-flight requests\n                        this.sourceCache[location] = xhrPromise;\n                        xhrPromise.then(resolve, reject);\n                    }\n                }\n            }.bind(this));\n        };\n\n        /**\n         * Creating SourceMapConsumers is expensive, so this wraps the creation of a\n         * SourceMapConsumer in a per-instance cache.\n         *\n         * @param {String} sourceMappingURL = URL to fetch source map from\n         * @param {String} defaultSourceRoot = Default source root for source map if undefined\n         * @returns {Promise} that resolves a SourceMapConsumer\n         */\n        this._getSourceMapConsumer = function _getSourceMapConsumer(sourceMappingURL, defaultSourceRoot) {\n            return new Promise(function(resolve, reject) {\n                if (this.sourceMapConsumerCache[sourceMappingURL]) {\n                    resolve(this.sourceMapConsumerCache[sourceMappingURL]);\n                } else {\n                    var sourceMapConsumerPromise = new Promise(function(resolve, reject) {\n                        return this._get(sourceMappingURL).then(function(sourceMapSource) {\n                            if (typeof sourceMapSource === 'string') {\n                                sourceMapSource = _parseJson(sourceMapSource.replace(/^\\)\\]\\}'/, ''));\n                            }\n                            if (typeof sourceMapSource.sourceRoot === 'undefined') {\n                                sourceMapSource.sourceRoot = defaultSourceRoot;\n                            }\n\n                            resolve(new SourceMap.SourceMapConsumer(sourceMapSource));\n                        }, reject);\n                    }.bind(this));\n                    this.sourceMapConsumerCache[sourceMappingURL] = sourceMapConsumerPromise;\n                    resolve(sourceMapConsumerPromise);\n                }\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, enhance function name and use source maps for a\n         * better StackFrame.\n         *\n         * @param {StackFrame} stackframe object\n         * @returns {Promise} that resolves with with source-mapped StackFrame\n         */\n        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {\n            return new Promise(function(resolve, reject) {\n                this.getMappedLocation(stackframe).then(function(mappedStackFrame) {\n                    function resolveMappedStackFrame() {\n                        resolve(mappedStackFrame);\n                    }\n\n                    this.findFunctionName(mappedStackFrame)\n                        .then(resolve, resolveMappedStackFrame)\n                        ['catch'](resolveMappedStackFrame);\n                }.bind(this), reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, guess function name from location information.\n         *\n         * @param {StackFrame} stackframe\n         * @returns {Promise} that resolves with enhanced StackFrame.\n         */\n        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {\n            return new Promise(function(resolve, reject) {\n                _ensureStackFrameIsLegit(stackframe);\n                this._get(stackframe.fileName).then(function getSourceCallback(source) {\n                    var lineNumber = stackframe.lineNumber;\n                    var columnNumber = stackframe.columnNumber;\n                    var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);\n                    // Only replace functionName if we found something\n                    if (guessedFunctionName) {\n                        resolve(new StackFrame({\n                            functionName: guessedFunctionName,\n                            args: stackframe.args,\n                            fileName: stackframe.fileName,\n                            lineNumber: lineNumber,\n                            columnNumber: columnNumber\n                        }));\n                    } else {\n                        resolve(stackframe);\n                    }\n                }, reject)['catch'](reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.\n         *\n         * @param {StackFrame} stackframe\n         * @returns {Promise} that resolves with enhanced StackFrame.\n         */\n        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {\n            return new Promise(function(resolve, reject) {\n                _ensureSupportedEnvironment();\n                _ensureStackFrameIsLegit(stackframe);\n\n                var sourceCache = this.sourceCache;\n                var fileName = stackframe.fileName;\n                this._get(fileName).then(function(source) {\n                    var sourceMappingURL = _findSourceMappingURL(source);\n                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';\n                    var defaultSourceRoot = fileName.substring(0, fileName.lastIndexOf('/') + 1);\n\n                    if (sourceMappingURL[0] !== '/' && !isDataUrl && !(/^https?:\\/\\/|^\\/\\//i).test(sourceMappingURL)) {\n                        sourceMappingURL = defaultSourceRoot + sourceMappingURL;\n                    }\n\n                    return this._getSourceMapConsumer(sourceMappingURL, defaultSourceRoot)\n                        .then(function(sourceMapConsumer) {\n                            return _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache)\n                                .then(resolve)['catch'](function() {\n                                resolve(stackframe);\n                            });\n                        });\n                }.bind(this), reject)['catch'](reject);\n            }.bind(this));\n        };\n    };\n}));\n"]}